# Week 6: Java Reflection and Annotations

1. Reflection c√≥ th·ªÉ thay ƒë·ªïi c√°c th√†nh ph·∫ßn final trong m·ªôt l·ªõp ƒë∆∞·ª£c kh√¥ng? Code v√≠ d·ª• minh ho·∫° c√°ch thay ƒë·ªïi m·ªôt bi·∫øn static final.

- C√≥ th·ªÉ thay doi duoc c√°c th√†nh ph·∫ßn final trong 1 l·ªõp.
  VD:
  class Example {
  public static final String CONSTANT = "Hello, World!";
  }
  public class ReflectionExample {
  public static void main(String[] args) throws Exception {
  // L·∫•y ƒë·ªëi t∆∞·ª£ng Field c·ªßa bi·∫øn CONSTANT
  Field field = Example.class.getDeclaredField("CONSTANT");

          // B·ªè gi·ªõi h·∫°n truy c·∫≠p
          field.setAccessible(true);

          // Lo·∫°i b·ªè modifier FINAL
          Field modifiersField = Field.class.getDeclaredField("modifiers");
          modifiersField.setAccessible(true);
          modifiersField.setInt(field, field.getModifiers() & ~Modifier.FINAL);

          // Thay ƒë·ªïi gi√° tr·ªã c·ªßa CONSTANT
          field.set(null, "Modified Value!");

          // Ki·ªÉm tra l·∫°i gi√° tr·ªã
          System.out.println("Updated CONSTANT: " + Example.CONSTANT);
      }

  }

2. Reflection c√≥ ·∫£nh h∆∞·ªüng nh∆∞ th·∫ø n√†o ƒë·∫øn hi·ªáu su·∫•t c·ªßa m·ªôt ·ª©ng d·ª•ng Java?

N√≥ truy c·∫≠p ch·∫≠m h∆°n so v·ªõi vi·ªác truy c·∫≠p tr·ª±c ti·∫øp, kh√¥ng t·∫≠n dung ƒë∆∞·ª£c Just-in-time(JIT)c·ªßa JVM de t√°i s·ª≠ d·ª•ng code

3. R·ªßi ro v·ªÅ b·∫£o m·∫≠t khi s·ª≠ d·ª•ng reflection? L√†m th·∫ø n√†o ƒë·ªÉ gi·∫£m thi·ªÉu r·ªßi ro n√†y?

- Ph√° v·ª° t√≠nh ƒë√≥ng g√≥i, b·ªè qua quy·ªÅn truy c·∫≠p,... r·ªßi ro cao v·ªÅ b·∫£o m·∫≠t
- H·∫°n ch·∫ø s·ª≠ d·ª•ng Java Reflection khi kh√¥ng c·∫ßn thi·∫øt

4. L√†m th·∫ø n√†o ƒë·ªÉ truy c·∫≠p th√¥ng tin v·ªÅ nested classes v√† anonymous classes b·∫±ng Reflection?

- getDeclaredClasses() ‚Üí L·∫•y t·∫•t c·∫£ nested classes (k·ªÉ c·∫£ private).

- getClasses() ‚Üí L·∫•y nested classes public.

5. C∆° ch·∫ø ho·∫°t ƒë·ªông c·ªßa setAccessible(true)?

- Trong Java, ph∆∞∆°ng th·ª©c setAccessible(true) thu·ªôc l·ªõp AccessibleObject
  (m√† Field, Method, v√† Constructor k·∫ø th·ª´a) cho ph√©p truy c·∫≠p v√†o c√°c th√†nh ph·∫ßn private,
  protected, ho·∫∑c default c·ªßa m·ªôt l·ªõp th√¥ng qua Java Reflection.

6. Gi·∫£i th√≠ch c∆° ch·∫ø ho·∫°t ƒë·ªông c·ªßa Annotation Processor? L√†m th·∫ø n√†o ch√∫ng ƒë∆∞·ª£c t√≠ch h·ª£p v√†o qu√° tr√¨nh bi√™n d·ªãch?

- Annotation Processor cho ph√©p ki·ªÉm tra v√† generate ra code d·ª±a tr√™n Annotation trong qu√° tr√¨nh compile
- CH√∫ng ta c√≥ th·ªÉ t√≠ch h·ª£p v√†o qu√° tr√¨nh bi√™n d·ªãch khi d√πng tr·ª±c ti·∫øp javac
  javac -processor com.example.MyProcessor MyClass.java
  ho·∫∑c c≈©ng c√≥ th·ªÉ d√πng v·ªõi maven,gradle b·∫±ng c√°ch config

7. Annotation processors c√≥ ·∫£nh h∆∞·ªüng nh∆∞ th·∫ø n√†o ƒë·∫øn qu√° tr√¨nh bi√™n d·ªãch?

Annotation Processor l√†m tƒÉng th·ªùi gian bi√™n d·ªãch v√¨ tr√¨nh bi√™n d·ªãch ph·∫£i:

Qu√©t t·∫•t c·∫£ c√°c file ngu·ªìn ƒë·ªÉ t√¨m annotation.

Th·ª±c hi·ªán x·ª≠ l√Ω tr√™n c√°c annotation ƒë√≥.

C√≥ th·ªÉ ph·∫£i t·∫°o th√™m file m√£ ngu·ªìn m·ªõi.

N·∫øu c√≥ file m·ªõi, tr√¨nh bi√™n d·ªãch ph·∫£i bi√™n d·ªãch l·∫°i v√≤ng l·∫∑p (recompile) c√°c file m·ªõi sinh ra.

8.  L√†m th·∫ø n√†o ƒë·ªÉ t·∫°o m·ªôt annotation c√≥ th·ªÉ ƒë∆∞·ª£c k·∫ø th·ª´a?

@Inherited
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnnotation {
String value() default "Default Value";
}

@MyAnnotation("Applied to Parent")
class Parent {
}

class Child extends Parent {
}

public class TestInheritance {
public static void main(String[] args) {
Class<?> childClass = Child.class;
MyAnnotation annotation = childClass.getAnnotation(MyAnnotation.class);

        if (annotation != null) {
            System.out.println("Annotation value: " + annotation.value());
        } else {
            System.out.println("Annotation not inherited");
        }
    }

}

9. Ph√¢n bi·ªát c√°c lo·∫°i RetentionPolicy c·ªßa @Retention?

- RetentionPolicy.SOURCE:
  üîπ Annotation ch·ªâ t·ªìn t·∫°i trong m√£ ngu·ªìn v√† b·ªã lo·∫°i b·ªè khi bi√™n d·ªãch.
  üîπ Kh√¥ng c√≥ m·∫∑t trong file .class, kh√¥ng th·ªÉ truy xu·∫•t b·∫±ng Reflection.
  VD: @Override
- RetentionPolicy.CLASS:
  üîπ Annotation ƒë∆∞·ª£c gi·ªØ l·∫°i trong file .class nh∆∞ng kh√¥ng th·ªÉ truy xu·∫•t l√∫c runtime.
  üîπ Tr√¨nh bi√™n d·ªãch c√≥ th·ªÉ d√πng annotation n√†y, nh∆∞ng kh√¥ng th·ªÉ truy xu·∫•t b·∫±ng Reflection.
  üí° ·ª®ng d·ª•ng th·ª±c t·∫ø:

Annotation d√†nh cho compiler, nh∆∞ng kh√¥ng c·∫ßn l√∫c runtime.

Android framework s·ª≠ d·ª•ng nhi·ªÅu annotation CLASS (v√≠ d·ª•: @SuppressLint).

Annotation h·ªó tr·ª£ ProGuard (t·ªëi ∆∞u m√£ bytecode).

-RetentionPolicy.RUNTIME:
üîπ Annotation t·ªìn t·∫°i trong file .class v√† c√≥ th·ªÉ truy xu·∫•t l√∫c runtime b·∫±ng Reflection.
üîπ H·ªØu √≠ch cho framework, th∆∞ vi·ªán c·∫ßn ƒë·ªçc annotation trong l√∫c ch·∫°y.

üí° ·ª®ng d·ª•ng th·ª±c t·∫ø:

Spring (@Component, @Service, @Autowired): Spring s·ª≠ d·ª•ng c√°c annotation n√†y ƒë·ªÉ qu√©t bean l√∫c runtime.

JUnnnoit (@Test): JUnit t√¨m ki·∫øm atation @Test ƒë·ªÉ ch·∫°y c√°c unit test.

Hibernate (@Entity, @Table): Hibernate d√πng ƒë·ªÉ √°nh x·∫° class v·ªõi database.

10. S·ª± kh√°c bi·ªát gi·ªØa reflection v√† annotation processors trong vi·ªác x·ª≠ l√Ω annotation?

-Reflection - X·ª≠ l√Ω Annotation L√∫c Runtime:
üîπ C√°ch ho·∫°t ƒë·ªông:

D√πng Java Reflection API (java.lang.reflect) ƒë·ªÉ ƒë·ªçc metadata c·ªßa annotation.

Ch·ªâ ho·∫°t ƒë·ªông v·ªõi annotation c√≥ RetentionPolicy.RUNTIME.

Th∆∞·ªùng ƒë∆∞·ª£c d√πng trong c√°c framework nh∆∞ Spring, Hibernate, JUnit.

-Annotation Processor - X·ª≠ l√Ω Annotation L√∫c Compile-Time:

üîπ C√°ch ho·∫°t ƒë·ªông:

D√πng Annotation Processor (javax.annotation.processing.Processor) ƒë·ªÉ ph√¢n t√≠ch v√† x·ª≠ l√Ω annotation l√∫c bi√™n d·ªãch (compile-time).

Th∆∞·ªùng ƒë∆∞·ª£c d√πng ƒë·ªÉ t·∫°o code t·ª± ƒë·ªông, ki·ªÉm tra code ho·∫∑c bi·∫øn ƒë·ªïi m√£ ngu·ªìn tr∆∞·ªõc khi bi√™n d·ªãch.

Kh√¥ng th·ªÉ truy xu·∫•t l√∫c runtime, th∆∞·ªùng s·ª≠ d·ª•ng RetentionPolicy.SOURCE ho·∫∑c RetentionPolicy.CLASS.
